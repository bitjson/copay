{
  "version": 3,
  "file": "zxing-ngx-scanner.umd.min.js",
  "sources": [
    "ng://@zxing/ngx-scanner/node_modules/tslib/tslib.es6.js",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-multi-format-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.component.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.module.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "/// <reference path=\"./image-capture.d.ts\" />\n\nimport {\n  BinaryBitmap,\n  ChecksumException,\n  Exception,\n  FormatException,\n  HTMLCanvasElementLuminanceSource,\n  HybridBinarizer,\n  NotFoundException,\n  Reader,\n  Result,\n} from '@zxing/library';\n\nimport {\n  BehaviorSubject,\n  Observable,\n  Subscriber,\n  Subscription\n} from 'rxjs';\n\nimport { catchError } from 'rxjs/operators';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nexport class BrowserCodeReader {\n\n  /**\n   * The HTML video element, used to display the camera stream.\n   */\n  private videoElement: HTMLVideoElement;\n  /**\n   * Should contain the current registered listener for video play-ended,\n   * used to unregister that listener when needed.\n   */\n  private videoPlayEndedEventListener: EventListener;\n  /**\n   * Should contain the current registered listener for video playing,\n   * used to unregister that listener when needed.\n   */\n  private videoPlayingEventListener: EventListener;\n  /**\n   * Should contain the current registered listener for video loaded-metadata,\n   * used to unregister that listener when needed.\n   */\n  private videoLoadedMetadataEventListener: EventListener;\n\n  /**\n   * The HTML image element, used as a fallback for the video element when decoding.\n   */\n  private imageElement: HTMLImageElement;\n  /**\n   * Should contain the current registered listener for image loading,\n   * used to unregister that listener when needed.\n   */\n  private imageLoadedEventListener: EventListener;\n\n  /**\n   * The HTML canvas element, used to draw the video or image's frame for decoding.\n   */\n  private canvasElement: HTMLCanvasElement;\n  /**\n   * The HTML canvas element context.\n   */\n  private canvasElementContext: CanvasRenderingContext2D;\n\n  /**\n   * Used to control the decoding stream when it's open.\n   */\n  private decodingStream: Subscription;\n\n  /**\n   * The stream output from camera.\n   */\n  private stream: MediaStream;\n  /**\n   * The track from camera.\n   */\n  private track: MediaStreamTrack;\n  /**\n   * Shows if torch is available on the camera.\n   */\n  private torchCompatible = new BehaviorSubject<boolean>(false);\n\n  /**\n   * The device id of the current media device.\n   */\n  private deviceId: string;\n\n  /**\n   * Constructor for dependency injection.\n   *\n   * @param reader The barcode reader to be used to decode the stream.\n   * @param timeBetweenScans The scan throttling in milliseconds.\n   */\n  public constructor(protected readonly reader: Reader, private timeBetweenScans: number = 500) { }\n\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param callbackFn The callback to be executed after every scan attempt\n   * @param deviceId The device's to be used Id\n   * @param videoElement A new video element\n   *\n   * @todo Return Promise<Result>\n   */\n  public async decodeFromInputVideoDevice(\n    callbackFn?: (result: Result) => any,\n    deviceId?: string,\n    videoElement?: HTMLVideoElement\n  ): Promise<void> {\n\n    this.reset();\n\n    this.prepareVideoElement(videoElement);\n\n    // Keeps the deviceId between scanner resets.\n    if (typeof deviceId !== 'undefined') {\n      this.deviceId = deviceId;\n    }\n\n    const video = typeof deviceId === 'undefined'\n      ? { facingMode: { exact: 'environment' } }\n      : { deviceId: { exact: deviceId } };\n\n    const constraints: MediaStreamConstraints = {\n      audio: false,\n      video\n    };\n\n    if (typeof navigator === 'undefined') {\n      return;\n    }\n\n    try {\n      const stream = await navigator\n        .mediaDevices\n        .getUserMedia(constraints);\n\n      this.startDecodeFromStream(stream, callbackFn);\n\n    } catch (err) {\n      /* handle the error, or not */\n      console.error(err);\n    }\n  }\n\n  /**\n   * Sets the new stream and request a new decoding-with-delay.\n   *\n   * @param stream The stream to be shown in the video element.\n   * @param callbackFn A callback for the decode method.\n   *\n   * @todo Return Promise<Result>\n   */\n  private startDecodeFromStream(stream: MediaStream, callbackFn?: (result: Result) => any): void {\n    this.stream = stream;\n    this.checkTorchCompatibility(this.stream);\n    this.bindVideoSrc(this.videoElement, this.stream);\n    this.bindEvents(this.videoElement, callbackFn);\n  }\n\n  /**\n   * Defines what the videoElement src will be.\n   *\n   * @param videoElement\n   * @param stream\n   */\n  public bindVideoSrc(videoElement: HTMLVideoElement, stream: MediaStream): void {\n    // Older browsers may not have `srcObject`\n    try {\n      // @NOTE Throws Exception if interrupted by a new loaded request\n      videoElement.srcObject = stream;\n    } catch (err) {\n      // @NOTE Avoid using this in new browsers, as it is going away.\n      videoElement.src = window.URL.createObjectURL(stream);\n    }\n  }\n\n  /**\n   * Unbinds a HTML video src property.\n   *\n   * @param videoElement\n   */\n  public unbindVideoSrc(videoElement: HTMLVideoElement): void {\n    try {\n      videoElement.srcObject = null;\n    } catch (err) {\n      videoElement.src = '';\n    }\n  }\n\n  /**\n   * Binds listeners and callbacks to the videoElement.\n   *\n   * @param videoElement\n   * @param callbackFn\n   */\n  private bindEvents(videoElement: HTMLVideoElement, callbackFn?: (result: Result) => any): void {\n\n    if (typeof callbackFn !== 'undefined') {\n      this.videoPlayingEventListener = () => this.decodingStream = this.decodeWithDelay(this.timeBetweenScans)\n        .pipe(catchError((e, x) => this.handleDecodeStreamError(e, x)))\n        .subscribe((x: Result) => callbackFn(x));\n    }\n\n    videoElement.addEventListener('playing', this.videoPlayingEventListener);\n\n    this.videoLoadedMetadataEventListener = () => videoElement.play();\n\n    videoElement.addEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\n  }\n\n  /**\n   * Checks if the stream supports torch control.\n   *\n   * @param stream The media stream used to check.\n   */\n  private async checkTorchCompatibility(stream: MediaStream): Promise<void> {\n    try {\n      this.track = stream.getVideoTracks()[0];\n      const imageCapture = new ImageCapture(this.track);\n      const capabilities = await imageCapture.getPhotoCapabilities();\n      const compatible = !!capabilities.torch || ('fillLightMode' in capabilities && capabilities.fillLightMode.length !== 0);\n      this.torchCompatible.next(compatible);\n    } catch (err) {\n      this.torchCompatible.next(false);\n    }\n  }\n\n  /**\n   * Enables and disables the device torch.\n   */\n  public setTorch(on: boolean): void {\n    if (!this.torchCompatible.value) {\n      return;\n    }\n    if (on) {\n      this.track.applyConstraints({\n        advanced: [<any>{ torch: true }]\n      });\n    } else {\n      this.restart();\n    }\n  }\n\n  /**\n   * Observable that says if there's a torch available for the current device.\n   */\n  public get torchAvailable(): Observable<boolean> {\n    return this.torchCompatible.asObservable();\n  }\n\n  /**\n   * Sets a HTMLVideoElement for scanning or creates a new one.\n   *\n   * @param videoElement The HTMLVideoElement to be set.\n   */\n  private prepareVideoElement(videoElement?: HTMLVideoElement): void {\n\n    if (!videoElement && typeof document !== 'undefined') {\n      videoElement = document.createElement('video');\n      videoElement.width = 200;\n      videoElement.height = 200;\n    }\n\n    this.videoElement = videoElement;\n  }\n\n  /**\n   * Opens a decoding stream.\n   */\n  private decodeWithDelay(delay: number = 500): Observable<Result> {\n    // The decoding stream.\n    return Observable.create((observer: Subscriber<Result>) => {\n      // Creates on Subscribe.\n      const intervalId = setInterval(() => {\n        try {\n          observer.next(this.decode());\n        } catch (err) {\n          observer.error(err);\n        }\n      }, delay);\n      // Destroys on Unsubscribe.\n      return () => clearInterval(intervalId);\n    });\n  }\n\n  /**\n   * Gets the BinaryBitmap for ya! (and decodes it)\n   */\n  private decode(): Result {\n\n    // get binary bitmap for decode function\n    const binaryBitmap = this.createBinaryBitmap(this.videoElement || this.imageElement);\n\n    return this.decodeBitmap(binaryBitmap);\n  }\n\n  /**\n   * Call the encapsulated readers decode\n   */\n  protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\n    return this.reader.decode(binaryBitmap);\n  }\n\n  /**\n   * Administra um erro gerado durante o decode stream.\n   */\n  private handleDecodeStreamError(err: Exception, caught: Observable<Result>): Observable<Result> {\n\n    if (\n      // scan Failure - found nothing, no error\n      err instanceof NotFoundException ||\n      // scan Error - found the QR but got error on decoding\n      err instanceof ChecksumException ||\n      err instanceof FormatException\n    ) {\n      return caught;\n    }\n\n    throw err;\n  }\n\n  /**\n   * Creates a binaryBitmap based in some image source.\n   *\n   * @param mediaElement HTML element containing drawable image source.\n   */\n  private createBinaryBitmap(mediaElement: HTMLVideoElement | HTMLImageElement): BinaryBitmap {\n\n    if (undefined === this.canvasElementContext) {\n      this.prepareCaptureCanvas();\n    }\n\n    this.canvasElementContext.drawImage(mediaElement, 0, 0);\n\n    const luminanceSource = new HTMLCanvasElementLuminanceSource(this.canvasElement);\n    const hybridBinarizer = new HybridBinarizer(luminanceSource);\n\n    return new BinaryBitmap(hybridBinarizer);\n  }\n\n  /**\n   * ðŸ–Œ Prepares the canvas for capture and scan frames.\n   */\n  private prepareCaptureCanvas(): void {\n\n    if (typeof document === 'undefined') {\n\n      this.canvasElement = undefined;\n      this.canvasElementContext = undefined;\n\n      return;\n    }\n\n    const canvasElement = document.createElement('canvas');\n\n    let width: number;\n    let height: number;\n\n    if (typeof this.videoElement !== 'undefined') {\n      width = this.videoElement.videoWidth;\n      height = this.videoElement.videoHeight;\n    }\n\n    if (typeof this.imageElement !== 'undefined') {\n      width = this.imageElement.naturalWidth || this.imageElement.width;\n      height = this.imageElement.naturalHeight || this.imageElement.height;\n    }\n\n    canvasElement.style.width = width + 'px';\n    canvasElement.style.height = height + 'px';\n    canvasElement.width = width;\n    canvasElement.height = height;\n\n    this.canvasElement = canvasElement;\n    this.canvasElementContext = canvasElement.getContext('2d');\n  }\n\n  /**\n   * Stops the continuous scan and cleans the stream.\n   */\n  private stop(): void {\n\n    if (this.decodingStream) {\n      this.decodingStream.unsubscribe();\n    }\n\n    if (this.stream) {\n      this.stream.getVideoTracks().forEach(t => t.stop());\n      this.stream = undefined;\n    }\n\n  }\n\n  /**\n   * Resets the scanner and it's configurations.\n   */\n  public reset(): void {\n\n    // stops the camera, preview and scan ðŸ”´\n\n    this.stop();\n\n    if (this.videoElement) {\n\n      // first gives freedon to the element ðŸ•Š\n\n      if (typeof this.videoPlayEndedEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('ended', this.videoPlayEndedEventListener);\n      }\n\n      if (typeof this.videoPlayingEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\n      }\n\n      if (typeof this.videoLoadedMetadataEventListener !== 'undefined') {\n        this.videoElement.removeEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\n      }\n\n      // then forgets about that element ðŸ˜¢\n\n      this.unbindVideoSrc(this.videoElement);\n\n      this.videoElement.removeAttribute('src');\n      this.videoElement = undefined;\n    }\n\n    if (this.imageElement) {\n\n      // first gives freedon to the element ðŸ•Š\n\n      if (undefined !== this.videoPlayEndedEventListener) {\n        this.imageElement.removeEventListener('load', this.imageLoadedEventListener);\n      }\n\n      // then forgets about that element ðŸ˜¢\n\n      this.imageElement.src = undefined;\n      this.imageElement.removeAttribute('src');\n      this.imageElement = undefined;\n    }\n\n    // cleans canvas references ðŸ–Œ\n\n    this.canvasElementContext = undefined;\n    this.canvasElement = undefined;\n  }\n\n  /**\n   * Restarts the scanner.\n   */\n  private restart(): void {\n    // reset\n    // start\n    this.decodeFromInputVideoDevice(undefined, this.deviceId, this.videoElement);\n  }\n}\n",
    "import { MultiFormatReader, DecodeHintType, BinaryBitmap, Result } from '@zxing/library';\n\nimport { BrowserCodeReader } from './browser-code-reader';\n\nexport class BrowserMultiFormatReader extends BrowserCodeReader {\n\n  protected readonly reader: MultiFormatReader;\n\n  public constructor(\n    hints: Map<DecodeHintType, any> = null,\n    timeBetweenScansMillis: number = 500\n  ) {\n    const reader = new MultiFormatReader();\n    reader.setHints(hints);\n    super(reader, timeBetweenScansMillis);\n  }\n\n  /**\n   * Overwrite decodeBitmap to call decodeWithState, which will pay\n   * attention to the hints set in the constructor function\n   */\n  protected decodeBitmap(binaryBitmap: BinaryBitmap): Result {\n    return this.reader.decodeWithState(binaryBitmap);\n  }\n}\n",
    "import {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges,\n  ViewChild\n} from '@angular/core';\n\nimport { Result, DecodeHintType, BarcodeFormat, QRCodeReader } from '@zxing/library';\n\nimport { BrowserMultiFormatReader } from './browser-multi-format-reader';\nimport { BrowserCodeReader } from './browser-code-reader';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'zxing-scanner',\n  template: `<video #preview [style.object-fit]=\"previewFitMode\">\n  <p>\n    Your browser does not support this feature, please try to upgrade it.\n  </p>\n  <p>\n    Seu navegador nÃ£o suporta este recurso, por favor tente atualizÃ¡-lo.\n  </p>\n</video>\n`,\n  styles: [`:host{display:block}video{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}`],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ZXingScannerComponent implements AfterViewInit, OnDestroy, OnChanges {\n\n  /**\n   * The ZXing code reader.\n   */\n  private codeReader: BrowserCodeReader;\n\n  /**\n   * Has `navigator` access.\n   */\n  private hasNavigator: boolean;\n\n\n  /**\n   * Says if some native API is supported.\n   */\n  private isMediaDevicesSuported: boolean;\n\n  /**\n   * Says if some native API is supported.\n   */\n  private isEnumerateDevicesSuported: boolean;\n\n  /**\n   * List of enable video-input devices.\n   */\n  private videoInputDevices: MediaDeviceInfo[];\n  /**\n   * The current device used to scan things.\n   */\n  private videoInputDevice: MediaDeviceInfo;\n\n  /**\n   * If the user-agent allowed the use of the camera or not.\n   */\n  private hasPermission: boolean;\n\n  /**\n   * If any media device were found.\n   */\n  private set _hasDevices(hasDevice: boolean) {\n    this.hasDevices.next(hasDevice);\n  }\n\n  /**\n   * Reference to the preview element, should be the `video` tag.\n   */\n  @ViewChild('preview')\n  previewElemRef: ElementRef;\n\n  /**\n   * Barcode formats to scan\n   */\n  private _formats: BarcodeFormat[] = [BarcodeFormat.QR_CODE];\n\n  get formats() {\n    return this._formats;\n  }\n\n  @Input()\n  set formats(formatsInput: BarcodeFormat[]) {\n    if (typeof formatsInput === 'string') {\n      throw new Error('Formats shouldn\\'t be a string, make sure the [formats] input is a binding.');\n    }\n    // formats may be set from html template as BarcodeFormat or string array\n    const formats = <(string | BarcodeFormat)[]>formatsInput;\n    this._formats = formats.map(f => (typeof f === 'string') ? BarcodeFormat[f.trim()] : f);\n  }\n\n  /**\n   * Allow start scan or not.\n   */\n  @Input()\n  scannerEnabled = true;\n\n  /**\n   * The device that should be used to scan things.\n   */\n  @Input()\n  device: MediaDeviceInfo;\n\n  /**\n   * Enable or disable autofocus of the camera (might have an impact on performance)\n   */\n  @Input()\n  autofocusEnabled = true;\n\n  /**\n   * How the preview element shoud be fit inside the :host container.\n   */\n  @Input()\n  previewFitMode: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none' = 'cover';\n\n  /**\n   * Allow start scan or not.\n   */\n  @Input()\n  set torch(on: boolean) {\n    this.codeReader.setTorch(on);\n  }\n\n  /**\n   * Emitts events when the torch compatibility is changed.\n   */\n  @Output()\n  torchCompatible = new EventEmitter<boolean>();\n\n  /**\n   * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\n   */\n  @Output()\n  scanSuccess = new EventEmitter<string>();\n\n  /**\n   * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\n   */\n  @Output()\n  scanFailure = new EventEmitter<void>();\n\n  /**\n   * Emitts events when a scan throws some error, will inject the error to the callback.\n   */\n  @Output()\n  scanError = new EventEmitter<Error>();\n\n  /**\n   * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\n   */\n  @Output()\n  scanComplete = new EventEmitter<Result>();\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasFound = new EventEmitter<MediaDeviceInfo[]>();\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasNotFound = new EventEmitter<any>();\n\n  /**\n   * Emitts events when the users answers for permission.\n   */\n  @Output()\n  permissionResponse = new EventEmitter<boolean>();\n\n  /**\n   * Emitts events when has devices status is update.\n   */\n  @Output()\n  hasDevices = new EventEmitter<boolean>();\n\n  /**\n   * Constructor to build the object and do some DI.\n   */\n  constructor() {\n    this.codeReader = new BrowserCodeReader(new QRCodeReader(), 500);\n    this.hasNavigator = typeof navigator !== 'undefined';\n    this.isMediaDevicesSuported = this.hasNavigator && !!navigator.mediaDevices;\n    this.isEnumerateDevicesSuported = !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n  }\n\n  /**\n   * Manages the bindinded property changes.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n\n    if (changes.scannerEnabled) {\n      if (!this.scannerEnabled) {\n        this.resetScan();\n      } else if (this.videoInputDevice) {\n        this.scan(this.videoInputDevice.deviceId);\n      }\n    }\n\n    if (changes.device) {\n      if (this.device) {\n        this.changeDevice(this.device);\n      } else {\n        console.warn('zxing-scanner', 'device', 'Unselected device.');\n        this.resetScan();\n      }\n    }\n\n    if (changes.formats !== undefined) {\n      this.setFormats(this.formats);\n    }\n  }\n\n  /**\n   * Executed after the view initialization.\n   */\n  async ngAfterViewInit(): Promise<void> {\n\n    // Chrome 63 fix\n    if (!this.previewElemRef) {\n      console.warn('zxing-scanner', 'Preview element not found!');\n      return;\n    }\n\n    // iOS 11 Fix\n    this.previewElemRef.nativeElement.setAttribute('autoplay', false);\n    this.previewElemRef.nativeElement.setAttribute('muted', true);\n    this.previewElemRef.nativeElement.setAttribute('playsinline', true);\n    this.previewElemRef.nativeElement.setAttribute('autofocus', this.autofocusEnabled);\n\n    // Asks for permission before enumerating devices so it can get all the device's info\n    const hasPermission = await this.askForPermission();\n\n    // gets and enumerates all video devices\n    this.enumarateVideoDevices().then((videoInputDevices: MediaDeviceInfo[]) => {\n\n      if (videoInputDevices && videoInputDevices.length > 0) {\n        this._hasDevices = true;\n        this.camerasFound.next(videoInputDevices);\n      } else {\n        this._hasDevices = false;\n        this.camerasNotFound.next();\n      }\n\n    });\n\n    // There's nothin' to do anymore if we don't have permissions.\n    if (hasPermission !== true) {\n      return;\n    }\n\n    this.startScan(this.videoInputDevice);\n\n    this.codeReader.torchAvailable.subscribe((value: boolean) => {\n      this.torchCompatible.emit(value);\n    });\n  }\n\n  /**\n   * Executes some actions before destroy the component.\n   */\n  ngOnDestroy(): void {\n    this.resetScan();\n  }\n\n  /**\n   * Changes the supported code formats.\n   * @param formats The formats to support.\n   */\n  setFormats(formats: BarcodeFormat[]): void {\n\n    this.formats = formats;\n\n    const hints = new Map<DecodeHintType, any>();\n    hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n\n    this.codeReader = new BrowserMultiFormatReader(hints);\n\n    this.restartScan();\n  }\n\n  /**\n   * Properly changes the current target device.\n   *\n   * @param device\n   */\n  changeDevice(device: MediaDeviceInfo): void {\n    this.videoInputDevice = device;\n    this.startScan(device);\n  }\n\n  /**\n   * Properly changes the current target device using it's deviceId.\n   *\n   * @param deviceId\n   */\n  changeDeviceById(deviceId: string): void {\n    this.changeDevice(this.getDeviceById(deviceId));\n  }\n\n  /**\n   * Properly returns the target device using it's deviceId.\n   *\n   * @param deviceId\n   */\n  getDeviceById(deviceId: string): MediaDeviceInfo {\n    return this.videoInputDevices.find(device => device.deviceId === deviceId);\n  }\n\n  /**\n   * Sets the permission value and emmits the event.\n   */\n  private setPermission(hasPermission: boolean | null) {\n    this.hasPermission = hasPermission;\n    this.permissionResponse.next(hasPermission);\n    return this.permissionResponse;\n  }\n\n  /**\n   * Gets and registers all cammeras.\n   *\n   * @todo Return a Promise.\n   */\n  async askForPermission(): Promise<boolean> {\n\n    if (!this.hasNavigator) {\n      console.error('zxing-scanner', 'askForPermission', 'Can\\'t ask permission, navigator is not present.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    if (!this.isMediaDevicesSuported) {\n      console.error('zxing-scanner', 'askForPermission', 'Can\\'t get user media, this is not supported.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    let stream: MediaStream;\n\n    try {\n      // Will try to ask for permission\n      stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n    } catch (err) {\n      return this.handlePermissionException(err);\n    }\n\n    let permission: boolean;\n\n    try {\n\n      // Start stream so Browser can display its permission-dialog\n      this.codeReader.bindVideoSrc(this.previewElemRef.nativeElement, stream);\n\n      // After permission was granted, we can stop it again\n      stream.getVideoTracks().forEach(track => {\n        track.stop();\n      });\n\n      // should stop the opened stream\n      this.codeReader.unbindVideoSrc(this.previewElemRef.nativeElement);\n\n      // if the scripts lives until here, that's only one mean:\n\n      // permission granted\n      permission = true;\n      this.setPermission(permission);\n\n    } catch (err) {\n\n      console.error('zxing-scanner', 'askForPermission', err);\n\n      // permission aborted\n      permission = null;\n      this.setPermission(permission);\n    }\n\n    // Returns the event emitter, so the dev can subscribe to it\n    return permission;\n  }\n\n  /**\n   * Returns the filtered permission.\n   *\n   * @param err\n   */\n  private handlePermissionException(err: DOMException): boolean {\n\n    // failed to grant permission to video input\n\n    console.warn('zxing-scanner', 'askForPermission', err);\n\n    let permission: boolean;\n\n    switch (err.name) {\n\n      // usually caused by not secure origins\n      case 'NotSupportedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // could not claim\n        permission = null;\n        // can't check devices\n        this._hasDevices = null;\n        break;\n\n      // user denied permission\n      case 'NotAllowedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // claimed and denied permission\n        permission = false;\n        // this means that input devices exists\n        this._hasDevices = true;\n        break;\n\n      // the device has no attached input devices\n      case 'NotFoundError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // no permissions claimed\n        permission = null;\n        // because there was no devices\n        this._hasDevices = false;\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      case 'NotReadableError':\n        console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n        // no permissions claimed\n        permission = null;\n        // there are devices, which I couldn't use\n        this._hasDevices = false;\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      default:\n        console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n        // unknown\n        permission = null;\n        // this._hasDevices = undefined;\n        break;\n\n    }\n\n    this.setPermission(permission);\n\n    // tells the listener about the error\n    this.permissionResponse.error(err);\n\n    return permission;\n  }\n\n  /**\n   * Starts the continuous scanning for the given device.\n   *\n   * @param deviceId The deviceId from the device.\n   */\n  scan(deviceId: string): void {\n    try {\n\n      this.codeReader.decodeFromInputVideoDevice((result: Result) => {\n\n        if (result) {\n          this.dispatchScanSuccess(result);\n        } else {\n          this.dispatchScanFailure();\n        }\n\n        this.dispatchScanComplete(result);\n\n      }, deviceId, this.previewElemRef.nativeElement);\n\n    } catch (err) {\n      this.dispatchScanError(err);\n      this.dispatchScanComplete(undefined);\n    }\n  }\n\n  /**\n   * Starts the scanning if allowed.\n   *\n   * @param device The device to be used in the scan.\n   */\n  startScan(device: MediaDeviceInfo): void {\n    if (this.scannerEnabled && device) {\n      this.scan(device.deviceId);\n    }\n  }\n\n  /**\n   * Stops the scan service.\n   */\n  resetScan(): void {\n    this.codeReader.reset();\n  }\n\n  /**\n   * Stops and starts back the scan.\n   */\n  restartScan(): void {\n    this.resetScan();\n    this.startScan(this.device);\n  }\n\n  /**\n   * Dispatches the scan success event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanSuccess(result: Result): void {\n    this.scanSuccess.next(result.getText());\n  }\n\n  /**\n   * Dispatches the scan failure event.\n   */\n  private dispatchScanFailure(): void {\n    this.scanFailure.next();\n  }\n\n  /**\n   * Dispatches the scan error event.\n   *\n   * @param err the error thing.\n   */\n  private dispatchScanError(error: any): void {\n    this.scanError.next(error);\n  }\n\n  /**\n   * Dispatches the scan event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanComplete(result: Result): void {\n    this.scanComplete.next(result);\n  }\n\n  /**\n   * Enumerates all the available devices.\n   */\n  private async enumarateVideoDevices(): Promise<MediaDeviceInfo[]> {\n\n    if (!this.hasNavigator) {\n      console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, navigator is not present.');\n      return;\n    }\n\n    if (!this.isEnumerateDevicesSuported) {\n      console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, method not supported.');\n      return;\n    }\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    this.videoInputDevices = [];\n\n    for (const device of devices) {\n\n      // @todo type this as `MediaDeviceInfo`\n      const videoDevice: any = {};\n\n      // tslint:disable-next-line:forin\n      for (const key in device) {\n        videoDevice[key] = device[key];\n      }\n\n      if (videoDevice.kind === 'video') {\n        videoDevice.kind = 'videoinput';\n      }\n\n      if (!videoDevice.deviceId) {\n        videoDevice.deviceId = (<any>videoDevice).id;\n      }\n\n      if (!videoDevice.label) {\n        videoDevice.label = 'Camera (no permission ðŸš«)';\n      }\n\n      if (videoDevice.kind === 'videoinput') {\n        this.videoInputDevices.push(videoDevice);\n      }\n    }\n\n    return this.videoInputDevices;\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\nimport { ZXingScannerComponent } from './zxing-scanner.component';\n\nexport type ZXingScannerComponent = ZXingScannerComponent;\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule\n  ],\n  declarations: [ZXingScannerComponent],\n  exports: [ZXingScannerComponent],\n})\nexport class ZXingScannerModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: ZXingScannerModule\n    };\n  }\n}\n"
  ],
  "names": [
    "extendStatics",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "then",
    "apply",
    "__generator",
    "body",
    "f",
    "y",
    "t",
    "g",
    "_",
    "label",
    "sent",
    "trys",
    "ops",
    "verb",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "n",
    "v",
    "op",
    "TypeError",
    "call",
    "pop",
    "length",
    "push",
    "BrowserCodeReader",
    "reader",
    "timeBetweenScans",
    "torchCompatible",
    "BehaviorSubject",
    "prototype",
    "decodeFromInputVideoDevice",
    "callbackFn",
    "deviceId",
    "videoElement",
    "reset",
    "prepareVideoElement",
    "constraints",
    "audio",
    "video",
    "facingMode",
    "exact",
    "navigator",
    "mediaDevices",
    "getUserMedia",
    "stream",
    "_a",
    "startDecodeFromStream",
    "console",
    "error",
    "err_1",
    "checkTorchCompatibility",
    "bindVideoSrc",
    "bindEvents",
    "srcObject",
    "err",
    "src",
    "window",
    "URL",
    "createObjectURL",
    "unbindVideoSrc",
    "_this",
    "videoPlayingEventListener",
    "decodingStream",
    "decodeWithDelay",
    "pipe",
    "catchError",
    "x",
    "handleDecodeStreamError",
    "subscribe",
    "addEventListener",
    "videoLoadedMetadataEventListener",
    "play",
    "track",
    "getVideoTracks",
    "ImageCapture",
    "getPhotoCapabilities",
    "capabilities",
    "compatible",
    "torch",
    "fillLightMode",
    "setTorch",
    "on",
    "applyConstraints",
    "advanced",
    "restart",
    "defineProperty",
    "get",
    "asObservable",
    "document",
    "createElement",
    "width",
    "height",
    "delay",
    "Observable",
    "create",
    "observer",
    "intervalId",
    "setInterval",
    "decode",
    "clearInterval",
    "binaryBitmap",
    "createBinaryBitmap",
    "imageElement",
    "decodeBitmap",
    "caught",
    "NotFoundException",
    "ChecksumException",
    "FormatException",
    "mediaElement",
    "undefined",
    "canvasElementContext",
    "prepareCaptureCanvas",
    "drawImage",
    "luminanceSource",
    "HTMLCanvasElementLuminanceSource",
    "canvasElement",
    "hybridBinarizer",
    "HybridBinarizer",
    "BinaryBitmap",
    "videoWidth",
    "videoHeight",
    "naturalWidth",
    "naturalHeight",
    "style",
    "getContext",
    "stop",
    "unsubscribe",
    "forEach",
    "videoPlayEndedEventListener",
    "removeEventListener",
    "removeAttribute",
    "imageLoadedEventListener",
    "BrowserMultiFormatReader",
    "_super",
    "hints",
    "timeBetweenScansMillis",
    "MultiFormatReader",
    "setHints",
    "__extends",
    "__",
    "constructor",
    "tslib_1.__extends",
    "decodeWithState",
    "ZXingScannerComponent",
    "_formats",
    "BarcodeFormat",
    "QR_CODE",
    "scannerEnabled",
    "autofocusEnabled",
    "previewFitMode",
    "EventEmitter",
    "scanSuccess",
    "scanFailure",
    "scanError",
    "scanComplete",
    "camerasFound",
    "camerasNotFound",
    "permissionResponse",
    "hasDevices",
    "codeReader",
    "QRCodeReader",
    "hasNavigator",
    "isMediaDevicesSuported",
    "isEnumerateDevicesSuported",
    "enumerateDevices",
    "set",
    "hasDevice",
    "formatsInput",
    "Error",
    "formats",
    "map",
    "trim",
    "ngOnChanges",
    "changes",
    "videoInputDevice",
    "scan",
    "resetScan",
    "device",
    "changeDevice",
    "warn",
    "setFormats",
    "ngAfterViewInit",
    "previewElemRef",
    "nativeElement",
    "setAttribute",
    "askForPermission",
    "hasPermission",
    "enumarateVideoDevices",
    "videoInputDevices",
    "_hasDevices",
    "startScan",
    "torchAvailable",
    "emit",
    "ngOnDestroy",
    "Map",
    "restartScan",
    "changeDeviceById",
    "getDeviceById",
    "find",
    "setPermission",
    "handlePermissionException",
    "err_3",
    "permission",
    "name",
    "message",
    "dispatchScanSuccess",
    "dispatchScanFailure",
    "dispatchScanComplete",
    "dispatchScanError",
    "getText",
    "devices",
    "_b",
    "devices_1",
    "__values",
    "o",
    "m",
    "i",
    "tslib_1.__values",
    "devices_1_1",
    "key",
    "videoDevice",
    "kind",
    "id",
    "type",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ViewChild",
    "Input",
    "Output",
    "ZXingScannerModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "declarations",
    "exports"
  ],
  "mappings": "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"
}
